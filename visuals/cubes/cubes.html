<!DOCTYPE html>
<!-- saved from url=(0065)http://threejs.org/examples/webgl_interactive_draggablecubes.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>cubes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="./js/three.min.js"></script>
		<script src="./js/TrackballControls.js"></script>
		<script src="../../js/jquery.min.js"></script>

		<script>
			var container, stats;
			var camera, controls, scene, projector, renderer;
			var objects = [], plane;

			var mouse = new THREE.Vector2(),
			offset = new THREE.Vector3(),
			INTERSECTED, SELECTED;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1000;

				controls = new THREE.TrackballControls( camera );
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				scene = new THREE.Scene();

				scene.add( new THREE.AmbientLight( 0x505050 ) );

				// --- light 1 ------------------------------------------
				
				var light = new THREE.SpotLight( 0xffffff, 1.5 );
				light.position.set( 3000, 3000, 2000 );
				light.castShadow = true;
				//light.shadowCameraVisible = true

				light.shadowCameraNear = 200;
				light.shadowCameraFar = camera.far;
				light.shadowCameraFov = 50;

				light.shadowBias = -0.00022;
				light.shadowDarkness = 0.5;

				light.shadowMapWidth = 2048;
				light.shadowMapHeight = 2048;

				scene.add( light );
				
				// --- light 2 ------------------------------------------
				/*
				var light = new THREE.SpotLight( 0xffffff, .5 );
				light.position.set( -3000, 3000, 2000 );
				light.castShadow = true;
				//light.shadowCameraVisible = true

				light.shadowCameraNear = 200;
				light.shadowCameraFar = camera.far;
				light.shadowCameraFov = 50;

				light.shadowBias = -0.00022;
				light.shadowDarkness = 0.5;

				light.shadowMapWidth = 2048;
				light.shadowMapHeight = 2048;

				scene.add( light );
*/
				// --- ------------------------------------------
			COLORSETS = {}
  			COLORSETS.RAINBOWBRITE = new Array('#71c8bf', '#1ba554', '#cad93b', '#fef02f', '#fbb62c', '#f38a2e', '#ee592c', '#ea1d2b', '#b42767', '#65328f', '#52529f', '#20aeda')

				var geometry = new THREE.CubeGeometry( 40, 40, 40 );

				cubes = []
				var xmax = 10
				var ymax = 10
				var i = 0
				for ( var x = 0; x < xmax; x ++ ) 
				{
					for ( var y = 0; y < ymax; y ++ ) 
					{
						i = i + 1
						//var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
						var color = COLORSETS.RAINBOWBRITE[i % COLORSETS.RAINBOWBRITE.length]
						var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( 
							{ 
								color:  color, //0xffffff,
								wireframe: false 
							}
						));

						object.material.ambient = object.material.color;

						//object.position.x = Math.random() * 1000 - 500;
						//object.position.y = Math.random() * 600 - 300;
						//object.position.z = Math.random() * 800 - 400;

						object.position.x = (x- xmax/2)*100;
						object.position.y = (y -ymax/2)*100;
						object.position.z = 0;


					
						//object.rotation.x = Math.random() * 2 * Math.PI;
						//object.rotation.y = Math.random() * 2 * Math.PI;
						//object.rotation.z = Math.random() * 2 * Math.PI;

						var cubeSize = 2.41
						object.scale.x = cubeSize //Math.random() * 2 + 1;
						object.scale.y = cubeSize // Math.random() * 2 + 1;
						object.scale.z = cubeSize //Math.random() * 2 + 1;

						object.original = {}
						object.original.position = {}
						object.original.position.x = object.position.x
						object.original.position.y = object.position.y
						object.original.position.z = object.position.z
						object.original.scale = {}
						object.original.scale.x = object.scale.x
						object.original.scale.y = object.scale.y
						object.original.scale.z = object.scale.z
						object.target = {}
						object.target.position = {}
						object.target.scale = {}

						object.offsets.position = {}
						object.offsets.scale = {}
						//object.offsets.rotation = {}

						
						object.castShadow = true;
						object.receiveShadow = true;

						scene.add( object );

						objects.push( object );
						cubes.push(object)

					}
				}

				plane = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000, 8, 8 ), new THREE.MeshBasicMaterial( 
					{ color: 0x000000, opacity: 0.25, transparent: true, wireframe: true } 
				) );
				plane.visible = false;
				scene.add( plane );

				projector = new THREE.Projector();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.sortObjects = false;
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.shadowMapEnabled = true;
				renderer.shadowMapType = THREE.PCFShadowMap;

				container.appendChild( renderer.domElement );

				var info = document.createElement( 'div' );

				container.appendChild( info );

/*
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );
*/
				renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
				renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
				renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

				setupBindings()
				setupGlobals()
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				//

				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );

				var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );


				if ( SELECTED ) {

					var intersects = raycaster.intersectObject( plane );
					SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
					return;

				}


				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

						plane.position.copy( INTERSECTED.position );
						plane.lookAt( camera.position );

					}

					container.style.cursor = 'pointer';

				} else {

					if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

					container.style.cursor = 'auto';

				}

			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );

				/*
				var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					controls.enabled = false;

					SELECTED = intersects[ 0 ].object;

					var intersects = raycaster.intersectObject( plane );
					offset.copy( intersects[ 0 ].point ).sub( plane.position );

					container.style.cursor = 'move';

				}
				*/

			}

			function onDocumentMouseUp( event ) 
			{

				event.preventDefault();

				controls.enabled = true;

				if ( INTERSECTED ) {

					plane.position.copy( INTERSECTED.position );

					SELECTED = null;

				}

				container.style.cursor = 'auto';

			}

			function animate() 
			{
				requestAnimationFrame( animate );

				timeCount = timeCount + 1
				
				for ( var i = 0, l = cubes.length; i < l; i ++ ) 
				{
					var object = cubes[ i ];
					
					var dx = object.position.x
					var dz = object.position.y
					var r = Math.sqrt(dx*dx + dz*dz)
					
					//if (r == 0)
					{
						//object.position.y =  10*(1 + Math.sin( r/100 + timeCount *600))
						object.position.z =  50*(1.1 + Math.sin( r/100 + timeCount/20 ))
						//object.position.y = -object.scale.y
						//object.position.y += 1
						//object.position.set( 0, 0, 0 ); //Math.sin( timeCount *30)*10
						//object.overdraw = true
					}
				}
				
				doUpdates()
				render();
			}

			function render() 
			{
				controls.update();
				renderer.render( scene, camera );
			}

			function doUpdates()
			{
				//updateSpread()
				//updateSize()
				updateNames()
			}

			function updateSpread()
			{					
				spread.value += spread.speed
				
				for ( var i = 0, l = cubes.length; i < l; i ++ ) 
				{
					var object = cubes[ i ];
					object.position.x = object.original.position.x * spread.value
					object.position.y = object.original.position.y * spread.value
				}
				
				spread.speed *= .9
			}
			
			function updateSize()
			{					
				size.value += size.speed
				
				if (size.value < .1) { size.value = .1; }
				
				for ( var i = 0, l = cubes.length; i < l; i ++ ) 
				{
					var object = cubes[ i ];
					object.scale.x = object.original.scale.x * size.value
					object.scale.y = object.original.scale.y * size.value
				}
				
				size.speed *= .9
			}

			function setupGlobals()
			{
				timeCount = 0
				spread = { speed: 0, value: 1 }
				size   = { speed: 0, value: 1 }
				names  = { choice: 0, data: [] }
				
				names.data = [
					[
						[0,1,0,0,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,0],
						[1,0,1,0,0,0,0,1,0,1,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0],
						[1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0],
						[1,0,1,0,0,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,1,0,1,1,1]
					],

					[
						[1,1,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1],
						[1,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,0,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1],
						[1,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,0,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1],
						[1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,0,1]
					],

					[
						[1,1,1,0,1,0,0,1,0,0,0,0,1,1,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,0,0,1,0,0],
						[1,0,0,0,1,1,0,1,0,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0],
						[1,1,0,0,1,0,1,1,0,0,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0],
						[1,1,1,0,1,0,0,1,0,0,0,0,1,1,0,0,1,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,1]
					]
				]

				selectName(-1)
			}
			
			function updateNames()
			{
				//selectName()
				for ( var i = 0, l = cubes.length; i < l; i ++ ) 
				{
					var object = cubes[i];
					var rate = 0.02
					object.position.x += rate*(object.target.position.x - object.position.x)
					object.position.y += rate*(object.target.position.y - object.position.y)
					object.scale.x += rate*(object.target.scale.x - object.scale.x)
					object.scale.y += rate*(object.target.scale.y - object.scale.y)
					object.scale.z += rate*(object.target.scale.z - object.scale.z)
				}
			}	
				
			function selectName(choice)
			{
				names.choice = choice
				var cubesCopy = shuffleArray(cubes.slice(0));

				for ( var i = 0, l = cubes.length; i < l; i ++ ) 
				{
					var object = cubes[ i ];
					object.target.position.x = object.original.position.x
					object.target.position.y = object.original.position.y
					object.target.position.z = object.original.position.z
					object.target.scale.x = object.original.scale.x
					object.target.scale.y = object.original.scale.y
					object.target.scale.z = object.original.scale.z
				//	object.material.opacity = 0
				}


				if (names.choice != -1)
				{
					var objNum = 0
					var rows = names.data[names.choice]
					
					for (var y = 0; y < rows.length; y ++)
					{
						var row = rows[y]
						for (var x = 0; x < row.length; x ++)
						{
							if (row[x] == 1)
							{
								var object = cubesCopy.pop()
								
								object.target.position.x = (x - row.length/2)*50
								object.target.position.y = -(y - rows.length/2)*50
								object.target.position.z = -10
								object.target.scale.x = 1.2
								object.target.scale.y = 1.2
								object.target.scale.z = 1
								//console.log("obj " + objNum + " x" + x + " y" + y)
								object.material.opacity = 1
								objNum ++
							}
						}
					}
					
					var object = null;
					while (object = cubesCopy.pop())
					{
						object.target.scale.x = 0.1
						object.target.scale.y = 0.1
						object.target.scale.z = 0.1
					}
					
				}
				


			}
			
			function setupBindings()
			{
			    $(document).bind('keydown', function(e) 
					{
						console.log("e.keyCode  = " + e.keyCode)
						if (e.keyCode == 80) { spread.speed +=.05 }
						if (e.keyCode == 79) { spread.speed -=.05 }
					
						if (e.keyCode == 76) { size.speed +=.05 }
						if (e.keyCode == 75) { size.speed -=.05 }	

						//if (e.keyCode == 77) { names.speed +=.05 }
						//if (e.keyCode == 78) { size.speed -=.05 }	
											
						if (e.keyCode == 48) { selectName(-1) }						
						if (e.keyCode == 49) { selectName(0) }						
						if (e.keyCode == 50) { selectName(1) }						
						if (e.keyCode == 51) { selectName(2) }						
					}
				);
			}
			
			function shuffleArray(o){ //v1.0
			    for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
			    return o;
			};
		</script>
		
		<div style="cursor: pointer;">
			<canvas width="1387" height="1062"></canvas>
			<div id=doc style="position: absolute; top: 10px; width: 100%; text-align: center;">
			</div>
			
	

</body></html>